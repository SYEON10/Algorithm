# [Silver III] 품질검사 - 5600 

[문제 링크](https://www.acmicpc.net/problem/5600) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

구현

### 학습

✨ Strict Weak Ordering
이번 문제에서 Strict Weak Ordering 을 만족하지 않는 cmp 함수를 만들어서 꽤 애를 먹었다...

작성한 cmp 코드는 다음과 같다.

```
bool cmp(const vector<int> &a, const vector<int> &b){
    if(a[3] == 1)
        return true;
    if(b[3] == 1)
        return false;

    return true;
}
```

위 cmp 함수는 비반사성과 비대칭성을 만족하지 않는다.
뭘 믿고 이런 코드를 썼는지... 😂

올바르게 코드를 쓰면 다음과 같다.

```
bool cmp(const vector<int> &a, const vector<int> &b){
    if(a[3] == 1 && b[3] != 1){
        return true;
    }
    if(a[3] != 1 && b[3] == 1){
        return false;
    }

    return a > b;
}
```
cmp 함수를 쓸 때 주의할 점
1. true 면 첫번째 인자가, false면 두번째 인자가 왼쪽으로 간다. (= 우선순위가 높아진다. )
2. Strict Weak Ordering 을 만족하게 작성하자.

- 비반사성(irreflexivity): 모든 x에 대해 R(x, x)는 거짓
- 비대칭성(asymmetry): 모든 x, y에 대해 R(x, y)가 참이면 R(y, x)는 거짓
- 추이성(transitivity): 모든 x, y, z에 대해 R(x, y)와 R(y, z)가 참이면 R(x, z)는 참
- 비비교성의 추이성(transitivity of incomparability): 모든 x, y, z에 대해 R(x, y)와 R(y, x)가 거짓이고 R(y, z)와 R(z, y)가 거짓이면 R(x, z)와 R(z, x)는 거짓

하지만 이 알고리즘에서 cmp 를 쓰는 건 별로 좋은 방법이 아니기는 하다.
차라리 [3]이 1인 경우와 아닌 경우를 나눠 받는 편이 더 좋다.

이외에는...

보기에 좀 더럽게 구현이 되어있는데, 함수로 나누든 if for문 등으로 들어가는 깊이를 낮추든 해서 깔끔하게 바꿀 수 있을 것 같다.

그리고 뭐든 더 좋은 방법(메모리, 시간, 등... )이 있지 않을까? 이렇게 부산스럽게 구현해야 하나?
하는 습관이 있는데... KISS 하게 가자!

물론 좋은 성능을 추구하는 것도 좋지만... 낮은 레벨에서 할 건 아닌 것 같다.
그건 dod를 공부할 때나 레벨이 더 올라간 후에 도전해보는 걸로 하고, 지금은 최대한 간단하고 깔끔하게 구현하는 방향에 초점을 두자.

### 제출 일자

2024년 1월 9일 23:49:56

### 문제 설명

<p>공장이는 기계 부품을 만드는 공장에서 품질 관리 책임자를 맡고 있다. 이 공장에서는 A, B, C 부품을 생산하는데, 매일 각 부품을 a, b, c개씩 생산한다. 그리고 부품 각각에는 1~a, a+1~a+b, a+b+1~a+b+c의 번호가 붙어있다. 그러나 모든 부품이 완벽하게 만들어지는 것은 아니라서 일부 부품은 결함이 있을 수도 있다. 이에 공장에서는 매일 부품 검사를 시행하는데 그 과정은 다음과 같다.</p>

<ul>
	<li>A, B, C 부품을 각각 하나씩 가져와 연결하고 작동시킨다.</li>
	<li>모든 부품이 정상인 경우 기계가 정상 작동하여 "합격"</li>
	<li>부품이 하나라도 고장 난 경우 기계가 오작동하여 "불합격"</li>
</ul>

<p>이 과정은 매우 정밀하므로 고장 난 부품이 섞여 있는데 우연히 제대로 작동하는 경우는 없다. 그러나 게으른 공장이는 검사 횟수가 충분하지 않더라도 검사를 끝내기도 한다. 공장이가 잘리지 않도록 검사 결과 목록이 주어졌을 때 모든 부품을 다음 세 가지 경우 중 어떤 것인지 분류해주도록 하자.</p>

<ul>
	<li>정상</li>
	<li>고장</li>
	<li>알 수 없음</li>
</ul>

### 입력 

 <p>1번째 줄에 전원의 개수 a, 모터의 개수 b, 케이블의 개수 c가 공백으로 구분되어 주어진다. (1 ≦ a, b, c ≦ 100)</p>

<p>2번째 줄에 검사 횟수 N이 주어진다. (1 ≦ N ≦ 1000)</p>

<p>이어서 N개의 줄에 검사 결과가 주어진다. 전원 번호 i, 모터 번호 j, 케이블 번호 k, 검사 결과 r이 공백으로 구분되어 주어지며, r=1인 경우 합격, r=0인 경우 불합격이다.</p>

### 출력 

 <p>a+b+c개의 줄에 걸쳐 부품이 어느 분류인지 출력한다.</p>

<ul>
	<li>부품 i가 고장인 경우 0</li>
	<li>부품 i가 정상인 경우 1</li>
	<li>부품 i가 고장인지 정상인지 알 수 없는 경우 2</li>
</ul>

